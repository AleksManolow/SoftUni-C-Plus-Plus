// task02, Един прост подход за компресиране на текст е да се намерят последователности от повтарящи се символи (напр. Abbbbccd, съдържа bbbb, което е последователност от символа b, повторен 4 пъти) и да се замени с дължината им, последвана от повторения символ. Например, ако имаме abbbbccd, този метод на компресия ще ни даде a4bccd.
//Имайте предвид, че всъщност компресираме последователност само ако комбинацията от дължината и символа е по - къса от последователността - последователността a е по - къса от писането на 1a, последователността cc е със същата дължина като записването на 2c, така че няма смисъл да се заменя тях - оставяме ги такива, каквито са.
//Получава се версията на текст, компресиран, както е описано по - горе.Вашата задача е да „декомпресирате“ текста така, както е изглеждал оригиналът преди компресията.Това означава, че всяка буква, предшествана от положително цяло число, трябва да бъде отпечатана толкова пъти, докато всяка буква, предшествана от друга буква, трябва
//да бъде отпечатана „както е“.
#include <iostream>
#include <string>
#include<cctype>
std::string readInput();
void decompressionString(std::string line);
int main()
{
	std::string line = readInput();
	decompressionString(line);
	return 0;
}
std::string readInput()
{
	std::string line;
	getline(std::cin, line);
	return line;
}
void decompressionString(std::string line)
{
	int digit = 0;
	for (size_t i = 0; i < line.size(); i++)
	{
		if (isdigit(line[i]))
		{
			digit = digit * 10;
			digit = digit + (line[i] - '0');
		}
		else
		{
			if (digit > 0)
			{
				for (size_t j = 0; j < digit; j++)
				{
					std::cout << line[i];
				}
			}
			else if(digit == 0)
			{
				std::cout << line[i];
			}
			digit = 0;

		}

	}
}
